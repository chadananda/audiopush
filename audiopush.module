<?php
// $Id$

/**
 * @file
 * Audiopush webservice - client interface module
 *
 * Provides access to the Audiopush webservice which generates audio files and podcasts
 * for any content type and then promotes those automatically bringing quality
 * traffic and backlinks to any site with quality content.
 */

/**    
  [ ] We need to keep track of autogenerated MP3's so that if we replace it
  with a real one, we don't overwrite the real one with a fake one 
  
  [ ] track revisions - we may need a revisionid column in there too.  We can tie revisions
  to request uuid.
**/

define("AUDIOPUSH_STATE_QUEUED", 1);   // queued for conversion 
define("AUDIOPUSH_STATE_ASSIGNED", 7); // job pushed to service
define("AUDIOPUSH_STATE_COMPLETE", 2); // job returned from service and saved
define("AUDIOPUSH_STATE_OVERRIDE", 4); // user uploaded audio, never replace
define('AUDIOPUSH_SERVICE', 'http://audio-push.com/xml_rpc.php');

define('AUDIOPUSH_REMOTE_SUBMITNODE', 'mp3service.submitNode');
define('AUDIOPUSH_REMOTE_CHECKNODE', 'mp3service.checkNode');
define('AUDIOPUSH_REMOTE_SUBMITPODCAST', 'mp3service.submitPodcast');
define('AUDIOPUSH_REMOTE_TESTTOKEN', 'mp3service.testToken'); 

define('audiopush_xmlrpc_submitnode_TIMEOUT_MINUTES', 60); 
define('AUDIOPUSH_TEST_TOKEN', 'autht0k3n');
define('DEFAULT_NODE_AUDIOTEMPLATE', '[site_name] audio [content_type] [site_url] [change_voice] Title: [node_title]. '.
    ' [content_type] contributed by [author] on [pub_date], [change_voice] [node_title], [change_voice] [node_body]');

// States from webservice
define("MP3_STATE_CREATED", 0);
define("MP3_STATE_PENDING", 1);
define("MP3_STATE_ASSIGNED", 7);
define("MP3_STATE_COMPLETE", 2);
define("MP3_STATE_ERROR", 3);
define("MP3_STATE_OVERRIDE", 4);

define('MP3_ERROR_ACCESS', 10);
define('MP3_ERROR_DUPE', 11);
define('MP3_ERROR_LENGTH', 12);
define('MP3_ERROR_CONFLICT', 13);

/******** dumb little CRUD ops *********/  
function audiopush_crud_update_state($nid, $state, $statustime=0) {
 if (!$statustime) $statustime = time(); 
 db_query("UPDATE {audiopush} SET state=%d,statustime=%d WHERE nid=%d", array($state, $statustime, $nid)); 
} 
function audiopush_crud_insert($nid, $uuid, $state, $statustime=0) {
 if (!$statustime) $statustime = time();
 audiopush_crud_delete($nid);
 db_query('INSERT INTO {audiopush} (nid,uuid,state,statustime) VALUES (%d, "%s", %d, %d)',
            array($nid, $uuid, $state, $statustime));
} 
function audiopush_crud_delete($nid) {
 db_query('DELETE FROM {audiopush} WHERE nid=%d', array($nid));
}
/******** end CRUD *********/

/**
 * Implementation of hook_init()
 * (code executed on non-cached page)
 *
 * Adds one link to RSS Podcast for each feed we generate
 */
function audiopush_init() {
  //$tags = nodewords_get();
  $types = variable_get('audiopush_audio_types', 'audio');
  $site_url = variable_get('audiopush_site_url', $GLOBALS['base_url']);
  $site_desc = variable_get('audiopush_site_description', variable_get('site_slogan', '')); 
  foreach ($types as $content_type) {
   $title = $content_type .' '. $site_desc;
   $url = $site_url .'/'. _audiopush_get_podacst_filepath($content_type); 
   drupal_set_html_head('<link rel="alternate" type="application/rss+xml" title="'. $title .'" href="'. $url .'" />');      
  }  
}
/**
 * Implementation of hook_menu()
 */
function audiopush_menu() {
  $items = array();
  $items['admin/settings/audiopush'] = array(
    'title' => t('AudioPush'),
    'description' => t('Settings for Audio-push.com WebService'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('audiopush_admin_settings_form', NULL),
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
  );
  $items['admin/settings/audiopush/settings'] = array(
    'title' => t('Settings'),
    'description' => t('Settings for AudioPush WebService'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('audiopush_admin_settings_form', NULL),
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
    'type'  => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );  
  $items['admin/settings/audiopush/log'] = array(
    'title' => t('Logs'),
    'description' => t('Recent conversion and promotion activity'),
    'page callback' => 'audiopush_admin_log',
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
    'type'  => MENU_LOCAL_TASK,
  );
  $items['admin/settings/audiopush/promotion'] = array(
    'title' => t('Promotion'),
    'description' => t('Promotion of podcast feeds'),
    'page callback' => 'audiopush_admin_promotion',
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
    'type'  => MENU_LOCAL_TASK,
  );
  

  $items['audiopush/view_audioformat'] = array(
    'title' => t('Audiopush View Audioformat'),
    'description' => t('View node as rendered by audio template'),
    'page callback' => 'audiopush_format_node_audio', 
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK,
  );


  $items['audiopush/delete/job'] = array(
    'title' => t('Audiopush Conversion Delete'),
    'description' => t('Delete job in queue'),
    'page callback' => 'audiopush_job_delete',
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK,
  ); 
  
  /*
    $items['audiopush/retry/job'] = array(
    'title' => t('Audiopush Retry Conversion'),
    'description' => t('Retry job in queue'),
    'page callback' => 'audiopush_job_retry',
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK,
  );
  */
  return $items;  
}
/**
 * Implementation of hook_simpletest().
 */
/*
function audiopush_simpletest() { 
  $dir = drupal_get_path('module', 'audiopush') .'/tests';
  $tests = file_scan_directory($dir, '\.test$');
  return array_keys($tests);
}
*/

/**
 * Implementation of hook_form_alter()
 */
function audiopush_form_alter(&$form, $form_state, $form_id) {
 $form_list = variable_get('audiopush_audio_types', NULL);
 if (count($form_list)<1) return;
 foreach ($form_list as $key => $val) $form_list[$key] = $val .'_node_form';
 if (in_array($form_id, $form_list)) { 

  // drupal_set_message(print_r($form_list, TRUE)); 
  $form['#attributes']['enctype'] = "multipart/form-data";
  $form['audiopush_podcast']  = array(
    '#type'         => 'fieldset',
    '#title'        => t('AudioPush Podcast Webservice'),
    '#collapsible' => TRUE,  
    '#collapsed' => FALSE,
    '#weight' => 10,
    '#description' => '',
  );

  $nid = (int)arg(1);
  $file_path = _audiopush_get_filepath_from_nid($nid);
  if (file_exists($file_path)) {
   if (module_exists('swftools')) $link = $file_path . swf($file_path);
    else $link = l($file_path, $file_path, array('attributes' => array('target' => '_blank')));
  }
  $audio_state = db_result(db_query("SELECT state FROM {audiopush} WHERE nid=%d", $nid));
  $reading = $audio_state == AUDIOPUSH_STATE_OVERRIDE ? '<b>Human Reading</b>' : 'Automated Reading: '.$audio_state;
  $view_recording_formatted = l('View text formatted for reading', 'audiopush/view_audioformat/'. $nid, array('attributes' => array('target' => '_blank'))) ;

  $form['audiopush_podcast']['audiopush_podcast_audio'] = array(
    '#type'     => 'file',
    '#title'    => t('Upload podcast audio (optional)'),
    // '#default_value' => $logo_path,   
    '#description' => $reading .': '. $link .'<br>'. $view_recording_formatted,
    '#weight' => 10,
   // '#submit' => '_audiopush_replace_audio',
  );
  $form['#attributes']['enctype'] = "multipart/form-data";
  $form['#submit'][] = '_audiopush_replace_audio';
  // $form['audiopush_podcast']['audiopush_podcast_audio']['#element_submit'] = '_audiopush_replace_audio';
   

  // for testing only
  //audiopush_cron_queue_nodes();
 }
}
function audiopush_job_delete() { 
 if (!($uuid = arg(3))) return;
 $file_path = _audiopush_get_filepath($uuid);
 
 db_query('DELETE FROM {files} WHERE filepath LIKE "%%%s"', $uuid);
 db_query('DELETE FROM {audiopush} WHERE uuid = "%s"', $uuid);
 
 file_delete($file_path);
 audiopush_cron_queue_nodes();
 
 drupal_set_message("Deleted audio file: $file_path");
 drupal_goto('admin/settings/audiopush/log');
}
/**
 *  Format node text as it will be output to the audio engine
 */  
function audiopush_format_node_audio($nid=0) {
 if (!$nid) $nid = (int)arg(2);
 //return '<h1>'. $nid .'</h1>';
 
 if (!$nid || !($node=node_load($nid))) return '';
 // grab node template and replace out the fields 
 $template = variable_get('audiopush_body_template', DEFAULT_NODE_AUDIOTEMPLATE);

 $replace['content_type'] = node_get_types('name', $node); 
 $site_url = variable_get('audiopush_site_url', $GLOBALS['base_url']); 
 $replace['site_name'] = variable_get('audiopush_site_name', _audiopush_extract_domain($GLOBALS['base_url']));
 $replace['node_title'] = $node->title; 
 $replace['author'] = $node->name;
 $replace['node_description'] = $node->teaser;
 $replace['page_url'] = $site_url .'/'. $node->path;
 $replace['pub_date'] =  date('d M Y', $node->changed); 
 $replace['site_domain'] = _audiopush_extract_domain($site_url);
 $replace['site_url'] = $site_url; 
 $replace['copyright'] = variable_get('audiopush_copyright', 'Copyright 2008-'. date('Y') .' - '. $GLOBALS['base_url']);
 $replace['language'] = variable_get('audiopush_language', 'en-us');
 $replace['site_slogan'] = variable_get('audiopush_site_description', variable_get('site_slogan', '')); 
 $replace['site_email'] = variable_get('audiopush_email', variable_get('site_mail', '')); 
 $replace['node_body'] = $node->body;
 
 $body = _audiopush_applytemplate($template, $replace);

 if ((int)arg(2)) {
   echo ('<h2>Node Body Text Formatted for Audio Reading</h2>'.
    '<tt><div style="margin:20px; padding:10px; border: 2px dashed silver">'. $body ."</div>" ); 
   exit;
 }
 return $body;
}
/**
 * TODO: implement this.
 */
function _audiopush_replace_audio($form, &$form_state) {   
 if (!($nid = $form['nid']['#value'])) return FALSE;

 audiopush_crud_update_state($nid, AUDIOPUSH_STATE_OVERRIDE); // so we don't trigger anything odd
 
 // pull uuid from audiopush table if possible
 $uuid = db_result(db_query('SELECT uuid FROM {audiopush} WHERE nid=%d', $nid));
 $target_filename = _audiopush_get_filepath($uuid); 

 //db_query("UPDATE {audiopush} SET status=%d WHERE nid=%d", AUDIOPUSH_STATE_OVERRIDE, $nid);
 // audiopush_crud_insert($nid, $uuid, AUDIOPUSH_STATE_OVERRIDE, filectime($target_filename));
 
 if ($file = file_save_upload('audiopush_podcast_audio', $validators, $dir, FILE_EXISTS_REPLACE)) {
  // drupal_set_message('Replacing Node Audio, deleting old file: '. $target_filename);
  unlink($target_filename);
  $source = $file->filepath;
  // merge header mp3 with file if possible
  if ($header_path = variable_get('audiopush_podcast_mp3header', '')) { 
   include_once(drupal_get_path('module', 'audiopush') .'/mp3tools.class.php');
   mp3tools::shell_mp3concat(array($header_path, $source), $target_filename);
  } else file_copy($source, $target_filename, FILE_EXISTS_REPLACE);
  // unlink($source);  //??
  _audiopush_set_file_permissions($target_filename); 
 }
 
 // make a note in the database // filectime($target_filename)
 //db_query("UPDATE {audiopush} SET status=%d, statustime=%d WHERE nid=%d", AUDIOPUSH_STATE_OVERRIDE, time(), $nid);
 audiopush_crud_update_state($nid, AUDIOPUSH_STATE_OVERRIDE);
}
/**
 * Admin settings form
 */
function audiopush_admin_settings_form() { 
  /**********************************
   *  WEBSERVICE CONNECTION
   */   
  $form['service_connection']  = array(
    '#type'         => 'fieldset',
    '#title'        => t('AudioPush Webservice'),   
  );

  $authtoken = variable_get('audiopush_authtoken', AUDIOPUSH_TEST_TOKEN);
  $description = t('Access token for Audiopush Webservice. Get yours here: ') . l('audio-push.com', 'http://audio-push.com');
  if ($authtoken) {
   if (audiopush_xmlrpc_testtoken($authtoken)) {
    $connected_html = "<img src='/". drupal_get_path('module', audiopush) ."/thumbs.gif' align='right' alt='token verified' height='100' />";
    $description = 'Access token accepted. Audio-push.com connection is active.';
   } else {
    drupal_set_message(xmlrpc_error_msg(), 'warning');
   }
  }

  $form['service_connection']['audiopush_service'] = array(
    '#type'         => 'textfield',
    '#title'        => t('AudioPush Service URL'),
    '#default_value' => variable_get('audiopush_service', AUDIOPUSH_SERVICE),
    '#description'  =>  t('URL of audio-push service, default: '). AUDIOPUSH_SERVICE,
    '#prefix'       => $connected_html,
  );

  $form['service_connection']['audiopush_authtoken'] = array(
    '#type'         => 'textfield',
    '#title'        => t('AudioPush Authentication Token'),
    '#default_value' => $authtoken,
    '#description'  => $description,
  );
  
  /**********************************
   *  SITE CONFIG
   */ 
  $form['site_config']  = array(
    '#type'         => 'fieldset',
    '#title'        => t('Site Configuration'),
    '#description'  => t('Configuration Details for ') . $GLOBALS['base_url'],
    '#collapsible' => TRUE,  
    '#collapsed' => TRUE,
  );
  /*
  $form['site_config']['audiopush_filesdir'] = array(
    '#type'     => 'textfield',
    '#title'    => t('AudioPush Files Subdirectory'),
    '#default_value' => variable_get('audiopush_filesdir', 'audiopush'),
    '#description'  => t('Where to store audiopush MP3 and XML files (under ' . file_directory_path() . ')'),
  );*/

  $form['site_config']['audiopush_site_name'] = array(
    '#type'     => 'textfield',
    '#title'    => t('Brief Site Name'),
    '#default_value' => variable_get('audiopush_site_name', _audiopush_extract_domain($GLOBALS['base_url'])), // user slogan 
  );
  
  $form['site_config']['audiopush_audio_types'] = array(
    '#type'     => 'checkboxes',
    '#title'    => t('Select content types to use for AudioPush'),
    '#default_value' => variable_get('audiopush_audio_types', 'audio'),
    '#options'  => audiopush_get_types(),
    '#multiple'  => TRUE,
    '#description'  => t('Selected content types will have an added AudioPush MP3 field and a Podcast'),
  );
  
  $form['site_config']['audiopush_site_keywords'] = array(
    '#type'     => 'textfield',
    '#title'    => t('Site keywords, comma delimited'),
    '#default_value' => _audiopush_cleanup_comma_delimited(variable_get('audiopush_site_keywords', '')),  
  );
  
  $form['site_config']['audiopush_lagtime'] = array(
    '#type'     => 'select',
    '#title'    => t('Submit delay'),
    '#default_value' => variable_get('audiopush_lagtime', 60),
    '#options'  => array(
      0  => t('None'),
      15 => t('15 minutes'),
      30 => t('30 minutes'),
      60  => t('1 hour'),
      120  => t('2 hours'),
      240  => t('4 hours'),                  
      720  => t('12 hours'),
      1440 => t('24 hours'),      
    ),
    '#description'  => t('Delay between node creation and audio conversion (allows time for additional edits)'),
  ); 
  
  $form['site_config']['audiopush_comments'] = array(
    '#type'     => 'checkbox',
    '#title'    => t('Append Comments to Audio?'), 
    '#default_value' => variable_get('audiopush_comments', 0),  
    '#description'  => t('Should comments be appended to the audiofile? (Not yet implemented)'),
  );
  
  
  
  /**********************************
   *  PODCAST OPTIONS
   */ 
  $form['podcast_options']  = array(
    '#type'         => 'fieldset',
    '#title'        => t('Podcast Configuration'),
    '#description'  => t('Podcast Formatting Options. Accepts these tokens: ') .
       '<br />'.' &nbsp; [title],[author],[pubdate],[site_name],[site_url],[comment_body],[change_voice],[node_type_name],[node_type_description]',
    '#collapsible' => TRUE,  
    '#collapsed' => TRUE,
  );
  
  $form['#attributes']['enctype'] = "multipart/form-data";
  $form['#submit'][] = '_audiopush_upload_logo_submit';
  $logo_path = variable_get('audiopush_podcast_logo', '');  
  if (file_exists($logo_path)) $logo_img = '<img src="/'. $logo_path .'" align="right" />';
  
  $form['podcast_options']['audiopush_podcast_image'] = array(
    '#type'     => 'file',
    '#title'    => t('Upload image for podcast, final size is 144x144'),
    '#default_value' => $logo_path,  
    '#prefix'   => $logo_img,
    '#description' =>   $logo_path,
  );

  $file_path = variable_get('audiopush_podcast_mp3header', '');
  if (file_exists($file_path)) {
    if (module_exists('swftools')) $link = "<div id='audio_player'>{$file_path}". swf($file_path) ."</div>";
     else $link = $file_path;
  }
  $form['#submit'][] = '_audiopush_upload_mp3header_submit'; 
  $form['podcast_options']['audiopush_podcast_mp3'] = array(
    '#type'     => 'file',
    '#title'    => t('Upload MP3header for podcast audio'),
     //'#default_value' => $mp3header_path,
     //'#prefix'   => $logo_img,
    '#description' => $link,
  );
  
  $form['podcast_options']['audiopush_podcast_title'] = array(
    '#type'     => 'textfield',
    '#title'    => t('Podcast Title'),
    '#default_value' => variable_get('audiopush_podcast_title', '[node_type_name] audio podcast'),
    //'#description'  => t('Title of content podcast feed'),
  );
  
  $form['podcast_options']['audiopush_podcast_description'] = array(
    '#type'     => 'textfield',
    '#title'    => t('Podcast Description'),
    '#default_value' => variable_get('audiopush_podcast_description', 'Audio feed of [node_type_name] from [site_name]'),
   // '#description'  => t('Description of content podcast feed'),
  );
  
  $form['podcast_options']['audiopush_site_url'] = array(
    '#type'     => 'textfield',
    '#title'    => t('This Site URL'),
    '#default_value' => variable_get('audiopush_site_url', $GLOBALS['base_url']), 
  );
  
  $form['podcast_options']['audiopush_site_description'] = array(
    '#type'     => 'textfield',
    '#title'    => t('Podcast Site Description'),
    '#default_value' => variable_get('audiopush_site_description', variable_get('site_slogan', '')), // user slogan 
  );
  
  $form['podcast_options']['audiopush_copyright'] = array(
    '#type'     => 'textfield',
    '#title'    => t('Podcast copyright'),
    '#default_value' => variable_get('audiopush_copyright', 'Copyright 2008-'. date('Y') .' - '. $GLOBALS['base_url']),  
  );     
  
  $form['podcast_options']['audiopush_language'] = array(
    '#type'     => 'textfield',
    '#title'    => t('Podcast language'),
    '#default_value' => variable_get('audiopush_language', 'en-us'),  
  );
  
  $form['podcast_options']['audiopush_email'] = array(
    '#type'     => 'textfield',
    '#title'    => t('Podcast webmaster email'),
    '#default_value' => variable_get('audiopush_email', variable_get('site_mail', '')),   
  );

/**********************************
   *  AUDIO OPTIONS
   */
  
  $form['audio_options']  = array(
    '#type'         => 'fieldset',
    '#title'        => t('Node Audio Configuration'),
    '#description'  => t('Audio Generation Options. You can use the following tokens: ') .
       '<br />'.'[title],[author],[pubdate],[site_name],[site_url],[node_body],[change_voice]',

    '#collapsible' => TRUE,  
    '#collapsed' => TRUE,
  );
  
  // TODO: create a set of templates - one for each node type
  $form['audio_options']['audiopush_body_template'] = array(
    '#type'     => 'textarea',
    '#title'    => t('Node Audio Template'),
    '#default_value' => variable_get('audiopush_body_template', DEFAULT_NODE_AUDIOTEMPLATE),
    '#description'  => t('Template for formatting audio output of each node.'),
  );
  
  
  $form['audio_options']['audiopush_alternate_voices'] = array(
    '#type'     => 'checkbox',
    '#title'    => t('Alternate voice each paragraph break.'), 
    '#default_value' => variable_get('audiopush_alternate_voices', 0),  
    '#description'  => t('Randomly change voices with each paragraph.'),
  );
  
  $form['audio_options']['audiopush_alternate_subheader_voices'] = array(
    '#type'     => 'checkbox',
    '#title'    => t('Alternate voice for sub-headers.'), 
    '#default_value' => variable_get('audiopush_alternate_subheader_voices', 1),  
    '#description'  => t('Use a different voice for subheaders (adds nice variation)'),
  ); 
  
  // podcast header text with tokens [title],[author],[pubdate],[site_name],[site_url],[author],[pause],[change_voice]
   // [site_name] audio [contenttype] [site_url] [change_voice] Title: [title]. [contenttype] contritubed by [author] [change_voice] [title] [change_voice]
  $comment_default = "[change_voice] On [pubdate], [author] comments: [change_voice] Title: [title], [comment_body]. ";
  $form['audio_options']['audiopush_comment_template'] = array(
    '#type'     => 'textarea',
    '#title'    => t('Comment Audio Template'),
    '#default_value' => variable_get('audiopush_comment_template', $comment_default),
    '#description'  => t('Template for formatting audio output of each comment. '),
  );
 

  return system_settings_form($form);  
}
/**
 * extra submit handler to save uploaded image
 */
function _audiopush_upload_logo_submit($form, &$form_state) {
 $dir = file_directory_path() .'/audiopush';  
 if (!file_check_directory($dir , TRUE)) return FALSE;
 // if file exists and is image, resize to 144 and save location
 
 if ($file = file_save_upload('audiopush_podcast_image', $validators, $dir)) {
  // scale image
  _audiopush_scale_rss_image($file->filepath); 
  $oldpath = $file->filepath;
  $file->filepath = $dir .'/podcast_logo.'. end(explode(".", $file->filename));
  // move temp file to permanent location
    // first cleanup old references in files table, if any
  db_query('DELETE FROM {files} WHERE filepath LIKE "%audiopush/podcast_logo.%"');
  file_copy($oldpath, $file->filepath, FILE_EXISTS_REPLACE);
  // update files table (including setting it to permenant status)
  $file->filesize = filesize($filepath);
  $file->status = 1;
  $file->timestamp = filectime($filepath);
  drupal_write_record('files', $file, 'fid');
  drupal_set_message('Updated file record: '. $file->filename);  
  // save reference
  variable_set('audiopush_podcast_logo', $file->filepath);
  variable_set('audiopush_podcast_logo_fid', $file->fid);
  // regenerate all podcast files to use new image
  
 } 
} 
function _audiopush_upload_mp3header_submit($form, &$form_state) {
 $dir = file_directory_path() .'/audiopush';
 if (!file_check_directory($dir , TRUE)) return FALSE;
 // validators should check if this is an mp3 file

 if ($file = file_save_upload('audiopush_podcast_mp3header', $validators, $dir)) {
  $oldpath = $file->filepath;
  $newpath = $dir .'/podcast_mp3header.mp3';
  $file->filepath = $newpath;
  
  // move temp file to permanent location
    // first cleanup old references in files table, if any
  db_query('DELETE FROM {files} WHERE filepath LIKE "%audiopush/podcast_mp3header.mp3"');
  file_move($oldpath, $file->filepath, FILE_EXISTS_REPLACE);

  // update files table (including setting it to permenant status)
  $file->filesize = filesize($filepath);
  $file->status = 1;
  $file->timestamp = filectime($filepath);
  drupal_write_record('files', $file, 'fid');
  // save reference
  variable_set('audiopush_podcast_mp3header', $newpath);
  variable_set('audiopush_podcast_mp3header_fid', $file->fid);
  drupal_set_message('Updated file record: '. $newpath);
  
 }
}
/**
 * Implementation of hook_cron()
 */
function audiopush_cron() {
  $start_time = time();

  _audiopush_rebuild_podcast('aggregation_item');

  // rebuild and prmote podcast files
  audiopush_cron_rebuild_podcasts($start_time);  

  // get all processed nodes from webservice
  if (!audiopush_cron_check_assigned($start_time)) return FALSE;  

  audiopush_cron_queue_nodes(); // roundup all content

  // once every ten minutes do a small content roundup 
  if (variable_get('Audiopush_small_roundup', 0) < strtotime('10 minutes ago')) {
    audiopush_cron_queue_nodes(2); // roundup content changed in the last two hours
    variable_set('Audiopush_small_roundup', time());
  }
  // once every day do a full content roundup 
  if (variable_get('Audiopush_full_roundup', 0) < strtotime('1 day ago')) {
    audiopush_cron_queue_nodes(); // roundup all content
    variable_set('Audiopush_full_roundup', time());
  }
 
  // continue processing pending submissions (exits if > 20 seconds)
  if (!audiopush_cron_submit_queued($start_time)) return FALSE;

  // rebuild and prmote podcast files
  audiopush_cron_rebuild_podcasts($start_time); 
  
}
/**
 * Mark nodes of selected types for conversion, which will be kicked off by cron hook.
 */
function audiopush_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  //if ($node->just_attaching_file == TRUE) return;
  $audiotypes = (array) variable_get('audiopush_audio_types', array());
  if (!$audiotypes[$node->type])  return;

  switch ($op) {
    case "insert":    
     /* if ($node->field_override[0]['value'] != "on") {
        if (in_array($node->type, $audiotypes)) {
          drupal_set_message(t("Marked this new page for MP3 generation"));          
          audiopush_crud_delete($node->nid, AUDIOPUSH_STATE_OVERRIDE);        
          audiopush_crud_insert($uuid, $node->nid, AUDIOPUSH_STATE_CREATED);
        }
      }
      else {
        db_query('DELETE FROM {audiopush} WHERE nid=%d', array($node->nid));
        audiopush_crud_insert($uuid, $node->nid, AUDIOPUSH_STATE_OVERRIDE);        
      } */
      break;
    case "update":    
    /*  if ($node->field_override[0]['value'] != "on") {
        if (in_array($node->type, $audiotypes)) {
          drupal_set_message(t("Marked this updated page for MP3 regeneration"));  
          audiopush_crud_delete($node->nid, AUDIOPUSH_STATE_OVERRIDE);
          audiopush_crud_delete($node->nid, AUDIOPUSH_STATE_CREATED);
          // shouldn't we delete the old mp3 file here?
          audiopush_crud_insert($uuid, $node->nid, AUDIOPUSH_STATE_CREATED);
        }
      }
      else {
        // Clear all pending jobs for this node and mark it as overridden
        db_query('DELETE FROM {audiopush} WHERE nid=%d', array($node->nid));
        audiopush_crud_insert($uuid, $node->nid, AUDIOPUSH_STATE_OVERRIDE);        
      }  */
      break;
    case "view":
      $mp3_path = _audiopush_get_filepath_from_nid($node->nid);
      $mp3_url = file_create_url($mp3_path);
      if (file_exists($mp3_path)) {
       if (module_exists('swftools')) $link = swf($mp3_path);
       else $link = '<div class="audiopush_url">'. l($mp3_url, $mp3_path, array('attributes' => array('target' => '_blank'))) .'</div>';
      }

      if ($a3===FALSE) {  // not the teaser
       $node->content['audiopush_audio']['#value'] = "<div class='audiopush_player'>{$link}</div>";
       $node->content['audiopush_audio']['#weight'] = 5;
      } else { // the teaser
       $node->content['audiopush_audio']['#value'] = "<div class='audiopush_player'>{$link}</div>";
       $node->content['audiopush_audio']['#weight'] = 5;
      }
      break;
  }
}
/**
 * Submit queued jobs to webservice from cron
 *
 * note: this calls a webservice so can be slow. This is why we exit 20 seconds after start_time.
 *       We can continue next cron call.
 */
function audiopush_cron_submit_queued($start_time) { 
 // gather all nodes with AUDIOPUSH_STATE_ASSIGNED mode and statustime to zero
 $ret = db_query("SELECT * FROM {audiopush} WHERE state=%d", AUDIOPUSH_STATE_QUEUED);
 while ($row = db_fetch_object($ret)) {
   if (strtotime('20 seconds ago') > $start_time) return FALSE; // make sure we don't time out
   audiopush_xmlrpc_submitnode($row->uuid, $row->nid); 
 }
 return TRUE;
}
/**
 * Cron based check webservice for completed nodes, starts from first submitted
 *
 * note: this calls a webservice so can be slow. This is why we exit 20 seconds after start_time.
 *       We can continue next cron call.
 */
function audiopush_cron_check_assigned($start_time) {
 $ret = db_query('SELECT * FROM {audiopush} WHERE state=%d ORDER BY statustime ASC', AUDIOPUSH_STATE_ASSIGNED);
 while ($row = db_fetch_object($ret)) { 
   if (strtotime('20 seconds ago') > $start_time) return FALSE; // make sure we don't time out
   audiopush_xmlrpc_checknode($row->uuid, $row->nid);
 }
 return TRUE;
}
/**
 * Rebuild podcasts and notify webservice for promotion
 **/
function audiopush_cron_rebuild_podcasts($start_time) {
  $rebuild_types = variable_get('audiopush_rebuild_podcast', NULL);
  // drupal_set_message('Rebuild types: <pre>'. print_r($rebuild_types, TRUE) .'</pre>');

  if (!count($rebuild_types)) return TRUE;
  foreach ($rebuild_types as $content_type=>$val) {
   if (strtotime('20 seconds ago') > $start_time) return FALSE; // make sure we don't time out
   if ($podcast_filename = _audiopush_rebuild_podcast($content_type)) {
    //$podcast_url = variable_get('audiopush_site_url', $GLOBALS['base_url']) .'/'. $podcast_filename;
    $podcast_url = file_create_url($podcast_filename);
    // now promote the sucker
    if (audiopush_xmlrpc_submitpodcast($podcast_url)) { 
     unset($rebuild_types[$content_type]);
     variable_set('audiopush_rebuild_podcast', $rebuild_types);
    }
   }
  }
  variable_set('audiopush_rebuild_podcast', NULL);
  return TRUE; 
}
/**
 * rounds up jobs that need queued  
 *
 */
function audiopush_cron_queue_nodes($hours_back = 876000) {
 $audiotypes = (array) variable_get('audiopush_audio_types', 'audio');
 $lagtime = variable_get('audiopush_lagtime', 60);  
 $placeholder = rtrim(str_repeat("'%s',", count($audiotypes)), ',');
 $nodes_query = "SELECT n.nid, a.uuid, a.statustime, a.state, n.changed FROM {node} n 
  LEFT OUTER JOIN {audiopush} a ON n.nid=a.nid
  WHERE n.type IN ({$placeholder})
    AND n.status=1
    AND ((NOT a.state=%d) OR (a.state IS NULL)) 
    AND from_unixtime(n.changed) < DATE_SUB(NOW(),INTERVAL %d MINUTE)
    AND from_unixtime(n.changed) > DATE_SUB(NOW(),INTERVAL %d HOUR) ";
 $args = array_merge($audiotypes, array(AUDIOPUSH_STATE_QUEUED, $lagtime, $hours_back));
 //drupal_set_message('SQL: <pre>'. $nodes_query .'<br> args: <br> '. print_r($args, true) .'</pre>'); 

 $ret = db_query($nodes_query, $args);   
 $row_count = mysql_num_rows($ret);

 //if ($row_count) drupal_set_message("Adding or updating {$row_count} node(s) in audiopush table");

 $submit_count = 0;
 while ($row = db_fetch_object($ret)) {  
  $do_submit = FALSE;
  $file_path = $row->uuid ? _audiopush_get_filepath($row->uuid) : '';

 // drupal_set_message("Node {$row->nid} state: {$row->state}");

  switch ($row->state) {
    case AUDIOPUSH_STATE_ASSIGNED:
     if ($row->statustime < strtotime('10 minutes ago')) $do_submit = TRUE; 
     break; 
    case AUDIOPUSH_STATE_COMPLETE:
     $do_submit = FALSE;
   //  if (!file_exists($file_path) OR ($row->statustime != $row->changed)) $do_submit = TRUE;
     break; 
    case AUDIOPUSH_STATE_OVERRIDE:
     if (!file_exists($file_path) OR ($row->statustime != filectime($file_path))) $do_submit = TRUE;
     break; 
    default: $do_submit = TRUE;  
  } 
  if ($do_submit) {
   //drupal_set_message("Submitting node {$row->nid} to audiopush table");
   $uuid = $row->uuid ? $row->uuid : uniqid('ap-', true);
     //audiopush_crud_insert($row->nid, $uuid, AUDIOPUSH_STATE_QUEUED);
   // filename should match the node filename 
   if ($filename = basename(drupal_lookup_path('alias', 'node/'. $row->nid))) $filename .= '.mp3';
    else $filename = $uuid .'.mp3';
   // insert into audiopush table
   db_query('DELETE FROM {audiopush} WHERE uuid="%s"', $uuid);
   db_query('INSERT INTO {audiopush} (nid,uuid,state,filename,statustime) VALUES (%d, "%s", %d, "%s", %d)',
            array($row->nid, $uuid, AUDIOPUSH_STATE_QUEUED, $filename, time())); 
   drupal_set_message("Queued node {$row->nid} for MP3 conversion: ". $filename);
   $submit_count++; 
  }
 } 
 if ($submit_count) drupal_set_message($submit_count .'/'. $row_count .' node(s) queued for MP3 conversion.');
}
/**
 * Request the audiopush webservice to promote the new or updated podcast
 */
function audiopush_xmlrpc_submitpodcast($podcast_url) {  
  $authtoken = variable_get('audiopush_authtoken', AUDIOPUSH_TEST_TOKEN);
  $url = variable_get('audiopush_service', AUDIOPUSH_SERVICE);
  $result = xmlrpc($url, AUDIOPUSH_REMOTE_SUBMITPODCAST, $authtoken, $podcast_url) ||
    xmlrpc($url, AUDIOPUSH_REMOTE_SUBMITPODCAST, $authtoken, $podcast_url);
  drupal_set_message('Submitted podcast for promotion: '. l($podcast_url));
  return $result;
}
/**
 * Notify remote conversion service that we have a node ready for MP3 conversion.
 * 
 */ 
function audiopush_xmlrpc_submitnode($uuid, $nid) {  
  $text = audiopush_format_node_audio($nid); 
  $authtoken = variable_get('audiopush_authtoken', AUDIOPUSH_TEST_TOKEN);
  $url = variable_get('audiopush_service', AUDIOPUSH_SERVICE);
  drupal_set_message('Submitting node <b>'. $nid .'</b> with authentication token <b>'. $authtoken .'</b> to <b>'. $url .'</b>.');
  if ($newstate = xmlrpc($url, AUDIOPUSH_REMOTE_SUBMITNODE, $authtoken, $uuid, $text)) {
    switch ($newstate['state']) {
      case MP3_ERROR_DUPE:
      case MP3_STATE_PENDING:
        audiopush_crud_update_state($nid, AUDIOPUSH_STATE_ASSIGNED);
        return TRUE; 
      case MP3_STATE_ERROR:
      default:
        drupal_set_message('Webservice submission failed. (internal error): <pre>'. print_r($newstate, TRUE) .'</pre>');
        //watchdog('audiopush', t('MP3 service submit failed (internal error)'), WATCHDOG_ERROR);
        break;
    }  
  } 
  else {
    drupal_set_message(xmlrpc_error_msg(), 'warning');
    /*watchdog('audiopush', t('MP3 submit request failed with errno = @errno and message = @mesg', 
      array('@errno' => xmlrpc_errno(), '@mesg' => xmlrpc_error_msg())), WATCHDOG_ERROR);*/
  }
  return FALSE;  
}
/**
 * Request the audiopush webservice to validate token
 */
function audiopush_xmlrpc_testtoken($authtoken) {
  $url = variable_get('audiopush_service', AUDIOPUSH_SERVICE);
  $result = xmlrpc($url, AUDIOPUSH_REMOTE_TESTTOKEN, $authtoken) ||  xmlrpc($url, AUDIOPUSH_REMOTE_TESTTOKEN, $authtoken);
  return $result;
}
/**
 * Poll remote service to find out if it's done converting our mp3 file
 */
function audiopush_xmlrpc_checknode($uuid, $nid) {
  //drupal_set_message("audiopush_xmlrpc_checknode {$uuid}");

  // $node = node_load($nid); 
  $authtoken = variable_get('audiopush_authtoken', AUDIOPUSH_TEST_TOKEN);
  $url = variable_get('audiopush_service', AUDIOPUSH_SERVICE);
  $response = xmlrpc($url, AUDIOPUSH_REMOTE_CHECKNODE, $authtoken, $uuid);
  
  if ($response != FALSE) {
    switch ($response['state']) {
      case MP3_STATE_COMPLETE:
        _audiopush_attach($nid, $uuid, $response['file'], $response['duration'], $response['keywords']);
       // drupal_set_message("audiopush_xmlrpc_checknode {$uuid}: MP3_STATE_COMPLETE" );
        return TRUE;
      case MP3_STATE_PENDING:
      case MP3_STATE_ASSIGNED:
       // drupal_set_message("audiopush_xmlrpc_checknode {$uuid}: MP3_STATE_PENDING or MP3_STATE_ASSIGNED");
        return TRUE; // just not done yet
      case MP3_STATE_ERROR:
        watchdog('audiopush', t('MP3 service submit failed (remote error)'), WATCHDOG_ERROR);
       // drupal_set_message("audiopush_xmlrpc_checknode {$uuid}: MP3_STATE_ERROR");
        return FALSE;
      default: 
        watchdog('audiopush', t('MP3 service submit gave us unknown return: @newstate', 
          array('@newstate' => $response['state'])), WATCHDOG_ERROR);
        //  drupal_set_message("audiopush_xmlrpc_checknode {$uuid}: ??");
        return FALSE;
    }  
  }
  else { 
   // drupal_set_message("MP3 submit request failed with errno = ". xmlrpc_errno() ." and message = ". xmlrpc_error_msg());
    watchdog('audiopush', t('MP3 submit request failed with errno = @errno and message = @mesg', 
        array('@errno' => xmlrpc_errno(), '@mesg' => xmlrpc_error_msg())), WATCHDOG_ERROR);
  }
  return FALSE;
}
/**
 * Get list of content types that can be selected as audio types
 */
function audiopush_get_types() {
  $ret = array();
  $types = node_get_types();
  foreach (array_keys($types) as $key) {
    $ret[$key] = $types[$key]->name;
  }
  return $ret;
}
/**
 * Manage items in mp3 conversion process
 */
function audiopush_admin_log() {
  
  audiopush_cron_queue_nodes();  
  audiopush_cron_check_assigned(time());
  
 
  // for testing only
  audiopush_cron();

  $header = array(
    array(
      'data'  => t('Node ID'),
      'field' => 'nid',
      'sort'  => 'asc'
    ), 
    array(
      'data'  => t('Statustime'),
      'field' => 'statustime',
      'sort'  => 'asc'
    ),
    array(
      'data'  => t('State'),
      'field' => 'state',
      'sort'  => 'asc'
    ),
    array(
      'data'  => t('Listen'),
      'field' => 'listen',
      'sort'  => 'asc'
    ),
    array(
      'data'  => t('Audio Format'),
      'field' => 'view',
      'sort'  => 'asc'
    ), 
  );
  
  $rows = array();
  $ret = db_query('SELECT * FROM {audiopush} ORDER BY statustime DESC');
  if (db_affected_rows() > 0) {
    while ($row = db_fetch_object($ret)) {
      if ($row->state == AUDIOPUSH_STATE_COMPLETE) {
       $file_path = _audiopush_get_filepath($row->uuid);
       if (file_exists($file_path)) {
        if (module_exists('swftools')) $listen = swf($file_path, array('methods'=>array('player'=>'generic_mp3')));
         else $listen = l('listen', $file_path, array('attributes' => array('target' => '_blank')));
       }
      } else $listen = '';
      $view_link = l('formatted text', 'audiopush/view_audioformat/'. $row->nid, array('attributes' => array('target' => '_blank'))) ;
      $state_name = _audiopush_state_name($row->state);

      $title = drupal_get_path_alias("node/{$row->nid}");
       if (strlen($title)> 40) $title = substr($title, 0, 40) .'...';
      $node_link = l("{$row->nid}", "node/{$row->nid}") ."<br>". "<div style='font-size:10px'>{$title}</div>";
      $rows[] = array(
        //l(drupal_get_path_alias("node/{$row->nid}"), "node/{$row->nid}", array('title' => $row->title, 'class' => '')),
        $node_link,
        date("M j, g:i a", $row->statustime),
        $state_name == 'complete' ? $state_name : "<b style='color:maroon'>{$state_name}</b> ",
        $listen,
        $view_link, 
        ($row->state == AUDIOPUSH_STATE_COMPLETE) ? l('[x] delete', "audiopush/delete/job/" . $row->uuid) : '',
       // l('[R] retry', "audiopush/retry/job/" . $row->uuid)
      );
    }
  }

  return theme('table', $header, $rows, array(), t('Submitted conversion jobs'));
}

function audiopush_admin_promotion() {
  // $files = _audiopush_podcast_filelist(); 
  $types = variable_get('audiopush_audio_types', array());
  $result = '<h2> Audiopush Podcast Feeds to Promote: </h2><br>';
  foreach ($types as $type) {
    $type_name = node_get_types('name', $type);
    $file = _audiopush_get_podacst_filepath($type);
    $url = file_create_url($file);
    $link =  l($url, $url, array('attributes'=>array('target'=>'_blank')));
    $verify = l('[validate]', 'http://feedvalidator.org/?url='.urlencode($url), array('attributes'=>array('target'=>'_blank')));
    $item_count = db_result(db_query("SELECT count(*) FROM {audiopush} a
     LEFT OUTER JOIN {node} n ON n.nid=a.nid
     WHERE n.status=1 AND n.type='%s'
      AND a.state=%d", array($type, AUDIOPUSH_STATE_COMPLETE)));    
    $result .=  "<li><h3 class='podcast'>{$type_name} Podcast ({$item_count} items, {$verify})</h3>".
      "&nbsp; <span style='font-size:14px;'>{$link}</span><br /><br /> </li>";
  }
  $instructions = file_get_contents(drupal_get_path('module', 'audiopush') . '/promotion_instructions.html');
  return "<ol class='podcast'>{$result}</ol> {$instructions}";
}
/** 
 * Attach a returned mp3 file to the appropriate node
 *
 * TODO: remove old file from DB if exists
 */
function _audiopush_attach($nid, $uuid, $filedata, $duration='', $keywords='') { 
  $filepath = _audiopush_get_filepath($uuid);
  $tmp = $filepath .'.tmp';
  $file_data = base64_decode($filedata);
  $node = node_load($nid);
  
  $bytes = file_put_contents($tmp, $file_data);
  
  // merge header mp3 with file if possible
  if ($header_path = variable_get('audiopush_podcast_mp3header', '')) { 
   include_once(drupal_get_path('module', 'audiopush') .'/mp3tools.class.php');
   mp3tools::shell_mp3concat(array($header_path, $tmp), $filepath);
   $bytes = filesize($filepath);
   unlink($tmp);
  } else rename($tmp, $filepath);


  if (!@chmod($filepath, 0664)) {
    watchdog('audiopush', 
      t('Could not set appropriate file permissions on @filepath', array('@filepath' => $filepath)), WATCHDOG_ERROR);
  }  
  watchdog('audiopush', t('Wrote @bytes bytes to output file @filepath : @filedata', 
    array('@bytes' => $bytes, '@filepath' => $filepath, '@filedata' => $file_data)), WATCHDOG_DEBUG);
    
  // build file object
  $file = new stdClass();
  $file->uid = $node->uid;
  $file->filename = basename($filepath);
  $file->filepath = $filepath;
  $file->filemime = 'audio/mpeg'; //module_exists('mimedetect') ? mimedetect_mime($file) : file_get_mimetype($file->filename);
  $file->filesize = filesize($filepath);
  $file->status = 1;
  $file->timestamp = filectime($filepath);
  //if (module_exists('filefield')) filefield_meta($file);

  // note: do we need a file verion id? what is that all about?
     // see code example: http://drupal.org/node/258765
    
  // Insert new record to the database.
  drupal_write_record('files', $file);
  foreach (module_implements('file_insert') as $module) {
    $function = $module .'_file_insert';
    $function($file);
  }  
  _field_file_cache($file); 
  
  // if there is an existing attachment, we blow it away in favor of this one.
  // NOTE does not remove the old attachment from the database  
  $node->audiopush_podcast[0] = (array)$file;
  
  // This lets the system know not to kick off another conversion request on hook_nodeapi
  // based on this node save.
  $node->just_attaching_file = TRUE;
  node_save($node);

  // update audiopush table to reflect new file id etc
    //audiopush_crud_insert($nid, $uuid, AUDIOPUSH_STATE_COMPLETE, $node->changed); 
  $ap = db_fetch_object(db_query('SELECT * FROM {audiopush} WHERE nid="%s"', $nid));
  $ap->filename = $file->filename;
  $ap->fid = $file->fid; 
  $ap->nid = $nid;
  $ap->state = AUDIOPUSH_STATE_COMPLETE;
  $ap->statustime = time();
  $ap->duration = $duration; // ?
  $ap->keywords = $keywords; // ?
  drupal_write_record('audiopush', $ap, 'uuid'); 
  

  // force rebuild of podcast file for this type
  $rebuild_types =  variable_get('audiopush_rebuild_podcast', NULL);
  $rebuild_types[$node->type] = TRUE;
  variable_set('audiopush_rebuild_podcast', $rebuild_types);
  //drupal_set_message('Rebuilding podcast for types: <pre>'. print_r($rebuild_types, true) .'</pre>');
}
/**
 * Convert state id's to real names
 */
function _audiopush_state_name($stateid) {

  $mp3states = array( 
    AUDIOPUSH_STATE_QUEUED => t('queued'),
    AUDIOPUSH_STATE_ASSIGNED => t('assigned'),
    AUDIOPUSH_STATE_COMPLETE => t('complete'),
   // AUDIOPUSH_STATE_ERROR => t('error'),
    AUDIOPUSH_STATE_OVERRIDE => t('override'),
  );

  return $mp3states[$stateid];
}
/**
 * Retry a stalled job
 */
function _audiopush_retry($uuid) {    
  //audiopush_crud_update_state($uuid, $nid, AUDIOPUSH_STATE_CREATED);
  watchdog('audiopush', 
    t('Audio for node @nid uuid @uuid has stalled, retrying.', array('@nid' => $nid, '@uuid' => $uuid)), WATCHDOG_WARNING);
}
/**
 * Callback to support deleting jobs from queue

 
 
 

/**
 * code to actually generate a podcast
 */
function _audiopush_rebuild_podcast($content_type) {
  drupal_set_message('Rebuilding podcast file for content type: '. $content_type);
  // gather array of nodes for this content type
  $node_count = db_result(db_query("SELECT count(*) FROM {audiopush} a
     LEFT OUTER JOIN {node} n ON n.nid=a.nid
     WHERE n.status=1 AND n.type='%s'
      AND a.state=%d", array($content_type, AUDIOPUSH_STATE_COMPLETE)));
  
 // drupal_set_message('got here A, node_count: '. $node_count);  

  if (!$node_count) return; 

  $site_url = variable_get('audiopush_site_url', $GLOBALS['base_url']);
  $site_email = variable_get('audiopush_email', variable_get('site_mail', ''));
  $site_keywords = _audiopush_cleanup_comma_delimited(variable_get('audiopush_site_keywords', ''));
 

  $item_template = '  <item> 
  <title><![CDATA[ [node_title] ]]></title>
   <description><![CDATA[ [node_description] ]]></description>
   <link>[page_url]</link>
   <pubDate>[pubdate]</pubDate>
   <enclosure url="[mp3_url]" length="[mp3_length]" type="audio/mpeg" />
   <itunes:duration>[mp3_duration]</itunes:duration>
   <itunes:author>[mp3_author]</itunes:author>
   <itunes:subtitle><![CDATA[ [node_subtitle] ]]></itunes:subtitle>
   <itunes:summary><![CDATA[ [node_teaser] ]]></itunes:summary> 
   <itunes:keywords>[node_keywords]</itunes:keywords> 
   <guid>[mp3_url]</guid>
  </item>';
  

  
  // gather array of nodes for this content type 
  $ret = db_query("SELECT a.nid,a.uuid,a.statustime,a.duration,a.filename,n.status,n.created,n.changed,n.type FROM {audiopush} a
     LEFT OUTER JOIN {node} n ON n.nid=a.nid
     WHERE n.status=1 AND n.type='%s'
      AND a.state=%d", array($content_type, AUDIOPUSH_STATE_COMPLETE));
 
  while ($row = db_fetch_object($ret)) {
   $mp3_file = _audiopush_get_filepath($row->uuid);
   
   if (file_exists($mp3_file)) {
    $item = '';
    $node = node_load($row->nid);
    $item['node_keywords'] = audiopush_node_keywords($node, $site_keywords);    
    $item['node_title'] = $node->title;
    $item['node_description'] = $node->teaser;
    $item['page_url'] = $site_url .'/'. $node->path;
    $item['pubdate'] =  date('D, d M Y H:i:s T', $row->changed); 
    $item['mp3_url'] = $site_url .'/'. $mp3_file;
    $item['mp3_length'] = filesize($mp3_file);
    $item['mp3_duration'] = $row->duration; // read from table?
    $item['mp3_author'] = $site_email;
    $item['node_subtitle'] = substr(strip_tags($node->teaser), 0, 100);
    $item['node_teaser'] = strip_tags($node->teaser);   
   } 
   $item_list .= _audiopush_applytemplate($item_template, $item) ."\n";
  }

  
  $podcast_template = '<?xml version="1.0"?>  
  <rss version="2.0" xmlns:itunes="http://www.itunes.com/DTDs/Podcast-1.0.dtd">
  <channel>
   <title><![CDATA[ [podcast_title] ]]></title>
   <link>[site_url]</link>
   <description><![CDATA[ [podcast_description] ]]></description>
   <language>[language]</language>
   <copyright>[copyright]</copyright> 
    <image>
     <width>[logo_image_width]</width> 
     <height>[logo_image_height]</height> 
     <link>[site_url]</link> 
     <title>[site_slogan]</title> 
     <url>[logo_url]</url> 
    </image>
   <lastBuildDate>[podcast_lastbuild_date]</lastBuildDate>
   <webMaster>[site_email]</webMaster>
    <itunes:copyright>[copyright]</itunes:copyright> 
    <itunes:explicit>No</itunes:explicit> 
    <itunes:keywords>[site_keywords]</itunes:keywords> 
    <itunes:link href="[logo_url]" rel="image" type="[image_mime]">[site_title]</itunes:link>
    <itunes:owner>
     <itunes:email>[site_email]</itunes:email> 
     <itunes:name>[site_domain]</itunes:name> 
    </itunes:owner>
   <ttl>1</ttl>
[item_list]
   </channel>
  </rss>';
  
 

 // now gather up data into $podcast array (site_url, podcast_description, copyright, image_width)
 // replace out folowing items: [node_type_name] [site_name] [site_title]

 // img data
 $logo_path = variable_get('audiopush_podcast_logo', '');
 if (file_exists($logo_path)) {
  list($logo_image_width, $logo_image_height, $type, $attr) = getimagesize($logo_path);
  $image_url = $site_url .'/'. $logo_path;
  $inf = pathinfo($logo_path);
  $image_ext = $inf['extension'];
 } 
 $podcast['logo_image_width'] = $logo_image_width;
 $podcast['logo_image_height'] = $logo_image_height;
 $podcast['logo_url'] = $image_url;
 $podcast['podcast_title'] = variable_get('audiopush_podcast_title', '[node_type_name] audio podcast');
 $podcast['site_url'] = $site_url;
 $podcast['podcast_description'] = variable_get('audiopush_podcast_description', 'Audio feed of [node_type_name] from [site_name]');
 $podcast['copyright'] = variable_get('audiopush_copyright', 'Copyright 2008-'. date('Y') .' - '. $GLOBALS['base_url']);
 $podcast['language'] = variable_get('audiopush_language', 'en-us');
 $podcast['site_slogan'] = variable_get('audiopush_site_description', variable_get('site_slogan', ''));
 $podcast['podcast_lastbuild_date'] = date('D, d M Y H:i:s T');
 $podcast['site_email'] = variable_get('audiopush_email', variable_get('site_mail', '')); 
 $podcast['site_keywords'] = variable_get('audiopush_site_keywords', '');
 $podcast['site_domain'] = _audiopush_extract_domain($site_url);  
 // embedd the list generated above
 $podcast['item_list'] = $item_list;
 $podcast['node_type_name'] = node_get_types('name', $content_type);
 $podcast['site_name'] = variable_get('audiopush_site_name', _audiopush_extract_domain($GLOBALS['base_url']));
 $podcast['site_title'] = variable_get('audiopush_site_description', variable_get('site_slogan', ''));
 $podcast['image_mime'] = "image/{$image_ext}"; 

 // finally, build full podcast
 $xml = _audiopush_applytemplate($podcast_template, $podcast);
 $xml = _audiopush_applytemplate($xml, $podcast);
 
 // save to file and set permissions
 $filepath = _audiopush_get_podacst_filepath($content_type);
 file_put_contents($filepath, $xml);
 _audiopush_set_file_permissions($filepath);

 // done
 //watchdog('audiopush', t('Updated podcast file: @filepath', array('@filepath' => $filepath)));

 //echo "<textarea style='width:100%; height:800px'>". $xml ."</textarea>";
// header ("content-type: text/xml"); 
/// echo $xml;
// die; 

 return $filepath;
}
/*
 * Gets a list of keywords for this node if available - ideally would pull from keyword suggestion module
 * Merges with site keywords without dups abd returns a comma-delimited list
 *
 */
function audiopush_node_keywords($node, $site_keywords){
 $result = _audiopush_cleanup_comma_delimited($node->top_keywords_rawlist .','. $site_keywords);
 return $result;
}
/*
 * takes what is supposed to be a comma-delimited list and makes sure it is
 *
 */
function _audiopush_cleanup_comma_delimited($list){
  $list = explode(',', $list);
  if (is_array($list)){
   foreach ($list as $key=>$item) $list[$key] = trim($item);
   $list = implode(',', $list);
   return $list;
  }
  else return '';
}
function _audiopush_extract_domain($url) {
 $domainarray = explode('.', $url);
 $index = count($domainarray)-1;
 return $domainarray[$index-1] .".". $domainarray[$index]; 
}
/**
 * replace all [key] items with array value
 */
function _audiopush_applytemplate($template, $array) { 
  foreach ($array as $item => $value) $template = str_replace("[$item]", $value, $template);
  return $template;  
}
/**
 * Retrieve the file associated with a record.
 * @param uuid the identifier for the record in question
 * @return path to the requested file.
 */
function _audiopush_get_filepath($uuid) {
  $dirpath = file_directory_path() .'/audiopush/audio';
  file_check_directory($dirpath, FILE_CREATE_DIRECTORY);
  $rec = db_fetch_object(db_query('SELECT * FROM {audiopush} WHERE uuid="%s"', $uuid));  
  if (empty($rec->filename)){
   // get node filename, change extenstion
   if (!($rec->filename = drupal_lookup_path('alias', $rec->nid))) $rec->filename = $uuid;
   $rec->filename .= '.mp3';
   drupal_write_record('audiopush', $rec, 'uuid'); 
  } 
  $path =  $dirpath .'/'. $rec->filename;
  return $path;
}
function _audiopush_get_filepath_from_nid($nid) {
  //drupal_set_message("Looking for audio for node: $nid");
  $dirpath = file_directory_path() .'/audiopush/audio';
  file_check_directory($dirpath, FILE_CREATE_DIRECTORY);
  $rec = db_fetch_object(db_query('SELECT * FROM {audiopush} WHERE nid=%d', $nid));
  if (empty($rec->filename)){
   // get node filename, change extenstion
   if (!($rec->filename = drupal_lookup_path('alias', $rec->nid))) $rec->filename = $uuid;
   $rec->filename .= '.mp3';
   drupal_write_record('audiopush', $rec, 'uuid');
  }
  $path =  $dirpath .'/'. $rec->filename;
  return $path;
}
function _audiopush_get_podacst_filepath($content_type) {
  $dirpath = file_directory_path() .'/audiopush';
  file_check_directory($dirpath, FILE_CREATE_DIRECTORY);
  $path =  $dirpath .'/'. $content_type .'_podcast.xml';
  return $path;
}
// returns list of podcast files
function _audiopush_podcast_filelist() {
  $types = variable_get('audiopush_audio_types', array());
  foreach ($types as $type) {
    $rss_file = _audiopush_get_podacst_filepath($type);
    if (file_exists($rss_file)) $result[] = $rss_file;
  }
 return $result;
}

/**
 *  util function for dumping variables to logs.  Yes I know about var_dump.
 */
if (!function_exists('sprint_r')) {
  function sprint_r($var) {
    ob_start();
    print_r($var);
    $ret = ob_get_contents();
    ob_end_clean();
    return $ret;
  }
}
/*
 * Scale image to 144x144 for compatiblility with RSS feed with no module dependency
 */
function _audiopush_scale_rss_image($file) { 
 // based on scaleImageFileToBlob example by francesco@essensys at http://www.php.net/imagecreatefromjpeg
    $source_pic = $file;
    $max_width = 144;
    $max_height = 144;

    list($width, $height, $image_type) = getimagesize($file);

    switch ($image_type) {
        case 1: $src = imagecreatefromgif($file); break;
        case 2: $src = imagecreatefromjpeg($file);  break;
        case 3: $src = imagecreatefrompng($file); break;
        default: return '';  break;
    }

    $x_ratio = $max_width / $width;
    $y_ratio = $max_height / $height;

    if (($width <= $max_width) && ($height <= $max_height)) {
      $tn_width = $width;
      $tn_height = $height;
    }
    elseif (($x_ratio * $height) < $max_height) {
      $tn_height = ceil($x_ratio * $height);
      $tn_width = $max_width;
    }
    else {
      $tn_width = ceil($y_ratio * $width);
      $tn_height = $max_height;
    }
    
    $tmp = imagecreateTRUEcolor($tn_width, $tn_height);

    /* Check if this image is PNG or GIF to preserve its transparency */
    if (($image_type == 1) OR ($image_type==3))  {
        imagealphablending($tmp, FALSE);
        imagesavealpha($tmp, TRUE);
        $transparent = imagecolorallocatealpha($tmp, 255, 255, 255, 127);
        imagefilledrectangle($tmp, 0, 0, $tn_width, $tn_height, $transparent);
    }
    imagecopyresampled($tmp, $src, 0, 0, 0, 0, $tn_width, $tn_height, $width, $height);
    imagedestroy($src); 
    
    // output temp image to file preserving transparency in gif and png
    switch ($image_type) {
        case 1: imagegif($tmp, $file); break;
        case 2: imagejpeg($tmp, $file, 100);  break; // best quality
        case 3: imagepng($tmp, $file, 0); break; // no compression
        default: echo ''; break;
    }  
    imagedestroy($tmp);
    
    // now write out new information to files table
    
}
/**
 * Set appropriate file permissions
 **/
function _audiopush_set_file_permissions($filepath) {
  if (!@chmod($filepath, 0664)) {
    watchdog('audiopush', t('Could not set appropriate file permissions on @filepath',
     array('@filepath' => $filepath)), WATCHDOG_ERROR);
  }   
}






